# 模块的选择

Vue 中发送网络请求有非常多的方式，那么, 在开发中, 如何选择呢?

传统的 Ajax 是基于 XMLHttpRequest(XHR)，为什么不用它呢?非常好解释，配置和调用方式等非常混乱。编码起来看起来就非常蛋疼。所以真实开发中很少直接使用，而是使用 jQuery-Ajax

在前面的学习中，我们经常会使用 jQuery-Ajax，相对于传统的 Ajax 非常好用

为什么不选择它呢?首先，我们先明确一点: 在 Vue 的整个开发中都是不需要使用 jQuery 了。那么，就意味着为了方便我们进行一个网络请求，特意引用一个 jQuery，你觉得合理吗?jQuery 的代码 1w+行.Vue 的代码才 1w+行。完全没有必要为了用网络请求就引用这个重量级的框架

官方在 Vue1.x 的时候，推出了 Vue-resource。但在 Vue2.0 退出后，Vue 作者就在 GitHub 的 Issues 中说明了去掉 vue-resource，并且以后也不会再更新

在说明不再继续更新和维护 vue-resource 的同时，作者还推荐了一个框架: axios。axios 有非常多的优点，并且用起来也非常方便

# 认识 axios

功能特点：

- 在浏览器中发送 XMLHttpRequests 请求
- 在 node.js 中发送 http 请求
- 支持 Promise API
- 拦截请求和响应
- 转换请求和响应数据

# axiox 请求方式

支持多种请求方式:

- `axios(config)`
- `axios.request(config)`
- `axios.get(url[, config])`
- `axios.delete(url[, config])`
- `axios.head(url[, config])`
- `axios.post(url[, data[, config]])`
- `axios.put(url[, data[, config]])`
- `axios.patch(url[, data[, config]])`

# 发送基本请求

## get 请求

```js
axios
  .get("http://152.136.185.210:8000/api/n3/home/data", {
    params: {
      type: "pop",
      page: 3,
    },
  })
  .then((res) => console.log(res))
  .catch((err) => console.log(err));
```

## 发送并发请求

有时候,我们可能需求同时发送两个请求

- 使用 axios.all,可以放入多个请求的数组.
- `axios.all([])`返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1,res2

```js
axios
  .all([
    axios({
      url: "http://123.207.32.32:8000/home/multidata",
    }),
    axios({
      url: "http://152.136.185.210:8000/api/n3/home/data",
      params: {
        type: "pop",
        page: 1,
      },
    }),
  ])
  .then(
    axios.spread((res1, res2) => {
      console.log(res1);
      console.log(res2);
    })
  );
```

## 全局配置

在上面的示例中,我们的 BaseURL 是固定的

- 事实上,在开发中可能很多参数都是固定的.
- 这个时候我们可以进行一些抽取,也可以利用 axios 的全局配置

```js
axios.defaults.baseURL = ‘123.207.32.32:8000’axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;
```

# axios 的实例

当我们从 axios 模块中导入对象时，使用的实例是默认的实例。当给该实例设置一些默认配置时，这些配置就被固定下来了。但是后续开发中，某些配置可能会不太一样

比如某些请求需要使用特定的 baseURL 或者 timeout 或者 content-Type 等，这个时候，我们就可以创建新的实例，并且传入属于该实例的配置信息

```js
const instance1 = axios.create({
  baseURL: "http://152.136.185.210:8000/api/n3",
  timeout: 5000,
});

instance1({
  url: "/home/multidata",
}).then((res) => console.log(res));

const instance2 = axios.create({
  baseURL: "http://123.207.32.32:8000",
});
instance2({
  url: "/home/multidata",
}).then((res) => console.log(res));
```

# 拦截器

axios 提供了拦截器，用于我们在发送每次请求或者得到相应后，进行对应的处理。

```js
const instance = axios.create({
  baseURL: "http://152.136.185.210:8000/api/n3",
  timeout: 10000,
});

// 请求拦截
instance.interceptors.request.use(
  (config) => {
    console.log(config);
    return config;
  },
  (err) => {
    console.log(err);
  }
);

// 响应拦截
instance.interceptors.response.use(
  (res) => {
    // console.log(res);
    return res.data;
  },
  (err) => {
    console.log(err);
  }
);
```

响应拦截中完成的事情：

- 响应的成功拦截中，主要是对数据进行过滤。
- 响应的失败拦截中，可以根据 status 判断报错的错误码，跳转到不同的错误提示页面。
